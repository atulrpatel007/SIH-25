

### **Architecture Overview**

The connection follows a standard layered architecture:

1.  **Frontend (React/React Native):** Makes HTTP requests to the backend.
2.  **Backend API (Python/Node.js/Java):** Receives requests, contains business logic.
3.  **Database Driver/ORM:** A library that translates backend code into SQL queries.
4.  **MySQL Database:** The database server storing the data.

The critical component is the **Database Driver** or **ORM (Object-Relational Mapper)** which acts as the bridge between the backend application and MySQL.

---

### **Step 1: Choosing the Technology Stack**

For a Python-based backend (as suggested in the problem statement), the most common choices are:

1.  **ORM:** **SQLAlchemy** (full-featured, powerful) or **Django ORM** (if using the Django framework). An ORM lets you interact with your database using Python objects and methods instead of writing raw SQL.
2.  **Database Driver:** **mysql-connector-python** or **PyMySQL**. The ORM uses this driver under the hood to communicate with the MySQL server.

We'll use **FastAPI** (a modern, high-performance Python web framework) with **SQLAlchemy ORM** for this example.

---

### **Step 2: Project Setup and Installation**

1.  **Create a project directory and virtual environment:**
    ```bash
    mkdir krishi-mitra-backend
    cd krishi-mitra-backend
    python -m venv venv
    source venv/bin/activate  # On Windows: .\venv\Scripts\activate
    ```

2.  **Install required packages:**
    ```bash
    pip install fastapi uvicorn sqlalchemy pymysql python-multipart
    # Alternatively, use `mysql-connector-python` instead of `pymysql`
    ```

---

### **Step 3: Database Configuration & Connection**

Create a file `database.py` to set up the connection to your MySQL database.

```python
# database.py

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Format: mysql+driver://username:password@host:port/database_name
SQLALCHEMY_DATABASE_URL = "mysql+pymysql://krishi_user:securepassword@localhost:3306/krishi_mitra_db"

# Create the SQLAlchemy Engine
# The engine is the starting point for any SQLAlchemy application.
# It’s a “home base” for the actual database and its DBAPI.
engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    pool_pre_ping=True,  # Optional: checks connection is alive before using it
    echo=True  # Optional: logs all SQL commands to the console (great for debugging)
)

# Create a SessionLocal class
# Each instance of this class will be a database session.
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create a Base class
# We will inherit from this class to create each of our database models (Python classes that represent SQL tables).
Base = declarative_base()

# Dependency Function to get a DB session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()  # Ensure the database connection is closed after the request is done.
```

---

### **Step 4: Defining Database Models (Schema in Code)**

Create a file `models.py`. Here, we define our tables as Python classes using SQLAlchemy's ORM syntax. This mirrors the SQL `CREATE TABLE` statements.

```python
# models.py

from sqlalchemy import Column, Integer, String, Float, Date, DateTime, Text, Enum, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base  # Import the Base we just created

class User(Base):
    __tablename__ = "users"

    user_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    phone_number = Column(String(15), unique=True, index=True, nullable=False)
    full_name = Column(String(255), nullable=False)
    language_code = Column(String(2), default='en', nullable=False)
    village = Column(String(255))
    district = Column(String(255), nullable=False)
    state = Column(String(255), default='Odisha')
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    # Establish relationship (optional, but very powerful for querying)
    farms = relationship("Farm", back_populates="owner")

class Farm(Base):
    __tablename__ = "farms"

    farm_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    user_id = Column(Integer, ForeignKey("users.user_id"), nullable=False) # Foreign Key
    farm_name = Column(String(255))
    area_hectares = Column(Float)

    # Establish relationships
    owner = relationship("User", back_populates="farms")
    crops = relationship("FarmCrop", back_populates="farm")

# ... Similarly, define all other tables (FarmCrop, SoilHealthData, etc.) ...
# Example for YieldPrediction
class YieldPrediction(Base):
    __tablename__ = "yield_predictions"

    prediction_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    farm_crop_id = Column(Integer, ForeignKey("farm_crops.farm_crop_id"), unique=True, nullable=False)
    prediction_date = Column(Date, nullable=False, server_default=func.current_date())
    predicted_yield_kg = Column(Float, nullable=False)
    confidence = Column(Float)
    model_version = Column(String(50))

    # Relationship
    farm_crop = relationship("FarmCrop", back_populates="yield_prediction")
```

**Important:** Run `Base.metadata.create_all(bind=engine)` in your main application to automatically create the tables in MySQL if they don't exist.

---

### **Step 5: Creating Pydantic Models (for Data Validation)**

FastAPI uses Pydantic models to define the structure of the request and response data. Create a `schemas.py` file.

```python
# schemas.py

from pydantic import BaseModel
from datetime import date
from typing import Optional

# Pydantic model for creating a User
class UserCreate(BaseModel):
    phone_number: str
    full_name: str
    district: str
    village: Optional[str] = None
    language_code: str = 'en'

# Pydantic model for responding with User data (doesn't include sensitive data)
class User(BaseModel):
    user_id: int
    phone_number: str
    full_name: str
    district: str

    class Config:
        orm_mode = True  # Tells Pydantic to read data from an ORM object, not just a dict

# ... Define schemas for all other data models (FarmCreate, Farm, YieldPrediction, etc.) ...
```

---

### **Step 6: Building the API Endpoints (Connecting Everything)**

Now, create your main application file (e.g., `main.py`) to build the API using FastAPI.

```python
# main.py

from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from database import get_db, engine
import models
import schemas

# Create tables (good for development, use Alembic for migrations in production)
models.Base.metadata.create_all(bind=engine)

app = FastAPI(title="Krishi Mitra API")

# API Endpoint to create a new user
@app.post("/users/", response_model=schemas.User, status_code=status.HTTP_201_CREATED)
def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    # Check if user already exists
    db_user = db.query(models.User).filter(models.User.phone_number == user.phone_number).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Phone number already registered")
    
    # Create a new User model instance from the request data
    db_user = models.User(**user.dict())
    
    # Add it to the database session and commit
    db.add(db_user)
    db.commit()
    db.refresh(db_user) # Refresh to get the new user_id from the database
    
    return db_user

# API Endpoint to get a user by ID
@app.get("/users/{user_id}", response_model=schemas.User)
def read_user(user_id: int, db: Session = Depends(get_db)):
    db_user = db.query(models.User).filter(models.User.user_id == user_id).first()
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return db_user

# API Endpoint to get yield predictions for a user's farms (Complex Query Example)
@app.get("/users/{user_id}/yield-predictions/")
def get_user_yield_predictions(user_id: int, db: Session = Depends(get_db)):
    # This query uses SQLAlchemy's relationship joins
    predictions = db.query(models.YieldPrediction).join(models.FarmCrop).join(models.Farm).filter(models.Farm.user_id == user_id).all()
    return predictions
```

---

### **Step 7: Running the Application**

1.  **Start the FastAPI server using Uvicorn:**
    ```bash
    uvicorn main:app --reload
    ```
    *   `main:app` means the `app` object in the `main.py` file.
    *   `--reload` enables auto-reload on code changes (for development only).

2.  **Interact with the API:**
    *   Go to `http://127.0.0.1:8000/docs` in your browser. FastAPI automatically provides **Swagger UI documentation** where you can test all your endpoints interactively.
    *   Use a tool like **Postman** or **curl** to send HTTP requests to your endpoints (e.g., `POST http://127.0.0.1:8000/users/` with a JSON body).

### **Summary of the Connection Flow**

1.  A **HTTP Request** arrives at a FastAPI endpoint (e.g., `POST /users/`).
2.  FastAPI validates the request body against the **Pydantic model** (`UserCreate`).
3.  The endpoint function uses the `get_db` dependency to get a **database session**.
4.  The function uses the session and **SQLAlchemy models** to query or insert data into the **MySQL database**.
5.  The driver (`PyMySQL`) sends the translated SQL command over the network to the MySQL server.
6.  The result comes back, is converted into Python objects by SQLAlchemy, and is returned by the endpoint.
7.  FastAPI validates the response against the output Pydantic model (`User`) and converts it to **JSON** for the frontend.

This structure ensures a clean, maintainable, and secure connection between your backend software and the MySQL database.
